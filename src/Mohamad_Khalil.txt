* General Design:
I decided to go with a "Pokemon" class to handle core logical aspects of the pokemon itself there, stuff like attacking,
resting, learning skills and using items are defined in methods there, however I felt like battling
and battle messages should have their own class, so I created the "Battle" class for that, and for the String representation of the objects I decided
to separate that to its own "Formatter" class which has static methods for that there, and I also have classes for items (Item)
and skills "Skill" and a class for the bag "ItemBag", the goal was to follow the single-responsibility principle which states that each class
should have a single responsibility to make the code more maintainable, so I tried as much as possible to keep purely the core aspects of the object
defined within it, and relied on other utility classes on generating not so key aspects of the object.
I felt like following the SRP made altering code and managing functionality a very intuitive process as everything kinda related to each other.

* Design Change:
At the start of the assignment there were only 4 types which didn't seem like a
lot of things to deal with in the battling aspect so what i did was use a simple
switch statement combined with if statements inside to handle how the damage
multiplier will be calculated, but then after the design change i quickly
realised that i would need another way to handle a changing amount of types that
would make adding additional types in the future easier and will make the code
cleaner to read and maintain, so i started thinking of ways to achieve this, my
first attempt was to keep track of the effective and ineffective types of each
type in the pokemon type enum, but then the enum got too smart for what its
supposed to do, so i moved that part of the code to its own class called TypeData which handles
everything that has to do with effectiveness and ineffectiveness, and in that
class I experimented with lots of java collections searching for the best one
for the job, i eventually settled with enum sets and enum maps, which are a very
efficient type of collection which was best because i was mostly dealing with
the same piece of data in many of the elements, so it was nice to have the
optimisation for that sort of functionality, the way it works is, when the
pokemon asks for the type data by doing getType(PokeType), the method first checks if the static final
enum map PokemonTypes is empty and if it is then it loads the types using the loadTypes() method, and after that we
can easily fetch the needed type data from the set, this makes our job as developers easier 
and more efficient as we can add new types seamlessly and let the program structure
handle it. Adding a new type went from having to add many if statements to handle
attacks to just adding an enum to a map.